/*
Input format:
N
Bx
Bz_0
Bz_1
...
Bz_N
J_{0,1}
J_{1,2}
...
J{n-2,n-1}
*/

#include <stdio.h>


const int N = 50;
const double Bx = 2;
// elements of Bz and J are randomly generated from uniform(-2, 2)
const double Bz[] = {0.8630112745355265, -1.8361911786276783, -0.9581256172704311, 0.4434780146571704, 0.5209785547715104, 1.443589099838559, 0.5587559925124821, -1.5882668497302252, -0.659125905054295, -1.0497631144312858, -0.3696561827524123, -0.3390816866334294, -0.5067320924924696, 1.5979368506032103, 1.699912492684919, -1.8252202214224948, -1.1210494702481197, -0.8420115104225983, -0.11616199355990053, 1.8603749140456385, -0.9821160815707963, 1.8264898561880667, 0.7350473531826665, 1.065491033604847, -0.7309381093711775, -0.2879111609943168, 0.35453001505915793, 1.5130271847866958, 0.4428221058229993, -0.760413150302099, 1.4810515278580625, -0.025168326122962714, -1.2502217239055424, 0.7814453536810508, -0.2591977865914692, -1.1218273718890797, 1.9894258503991678, 1.737794552084115, -1.5019482793093366, 0.1674275904603264, 0.0781243790822943, 0.8892504578240201, -0.8179785246886788, 0.6834743034827566, 1.9837911570739348, 0.7594613916687529, 0.06325619275500172, -1.6443457621712412, -1.9995347767594067, -0.2124420323758649};
const double J[] = {-0.787164856299329, -0.6199002313573865, -1.3830025264222545, -1.83247164408081, 1.5182446951552646, 1.380542359413277, -0.034911693578598246, 1.2362342231653938, 0.6904214058822418, -1.579276317118655, -0.6856322453770431, -0.44287591133365467, 0.5562654727782101, -0.2515813572139276, -1.1881498105174026, 0.1967730532189953, 0.2809634816202222, -0.7868279577217892, -1.4394444785727605, 1.573681679885595, 1.6837485482136887, 0.28841594688244054, 1.2864470619370407, 0.9495408586052627, -1.7573475762906106, -1.635443691031723, -1.0863024739616147, 1.212961577858307, -0.8171807161058822, -1.2684394946397974, 0.3356244818332401, -1.3300304986875089, -1.8559220413590025, -0.6388272589740986, 0.872199606441133, 0.13240836548349488, 0.9825660239207474, -0.059165024524421295, 1.7397643519352517, 0.3196160480466528, 1.2765104518135368, 0.41203729338032513, -1.8965976958865958, 0.49913676993830913, 1.9096744910139214, -0.8540083008943435, 1.921196733590548, -0.9495068031517149, -0.2938528165961922};

void CZ(qbit q1, qbit q2, double phi) {
    // printf("performing Controlled -2phi Z rotation\n");
    Rz(q2, -2.0*phi);
    CNOT(q1, q2);
    Rz(q2, phi);
    CNOT(q1, q2);
}

void ZcrossZ(qbit q1, qbit q2, double phi) {
    // printf("performing sigma_z cross sigma_z Hamiltonian\n");
    Rz(q1, phi);
    Rz(q2, -phi);
    CZ(q1, q2, -2.0*phi);
}


void IsingModel() {
    qbit reg[N];

    // Initialize all qubits to |+> state
    int n;
    for(n=0; n < N; n++) {
        PrepZ(reg[n], 0);
        H(reg[n]);
    }

    double T = 15;  // total duration of adiabatic evolution
    int M = 25;  // number of Trotter steps
    double dt = M / T;  // time per Trotter step

    int m;
    for(m = 1; m <= M; m++) {

        // Z-Z hamiltonian, executed in parallel
        for (n = 0; n < N-1; n += 2) {  // red pairs
            double phi = J[n] * (2.0*m - 1) / M;
            ZcrossZ(reg[n], reg[n + 1], phi);
        }
        for (n = 1; n < N-1; n += 2) {  // black pairs
            double phi = J[n] * (2.0*m - 1) / M;
            ZcrossZ(reg[n], reg[n + 1], phi);
        }

        double theta1 = (1.0 - (2.0*m-1)/M) * -2 * Bx * T / M;
        for (n = 0; n < N; n++) {
            H(reg[n]);
            Rz(reg[n], theta1);
            H(reg[n]);
        }

        // Bz hamiltonian
        for (n = 0; n < N; n++) {
            double theta2 = (1.0 - (2.0*m-1)/M) * -2 * Bz[n] * T / M;
            Rz(reg[n], theta2);
        }
    }


    for (n = 0; n < N; n++) {
        MeasZ(reg[0]);
    }
}


int main() {
    /*
    FILE *fp;
    fp = fopen("input.txt", "r");
    int N = 0;
    double Bx = 0;
    fscanf(fp, "%d", &N);
    fscanf(fp, "%lf", &Bx);
    double Bz[N];
    int i;
    for (i = 0; i < N; i++) {
        fscanf(fp, "%lf", &Bz[i]);
    }
    double J[N-1];
    for (i = 0; i < N-1; i++) {
        fscanf(fp, "%lf", &J[i]);
    }
    */
    
    IsingModel();
    return 0;
}
