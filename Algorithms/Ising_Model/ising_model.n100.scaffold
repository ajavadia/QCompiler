/*
Input format:
N
Bx
Bz_0
Bz_1
...
Bz_N
J_{0,1}
J_{1,2}
...
J{n-2,n-1}
*/

#include <stdio.h>


const int N = 100;
const double Bx = 2;
// elements of Bz and J are randomly generated from uniform(-2, 2)
const double Bz[] = {-0.7048562029544807, -1.0173126053837187, 1.03909829279718, 0.7268468238645105, 1.7851208243747294, -1.0208583095902641, -0.8493908807746235, -0.7584620975319463, -0.9606885404899352, 1.9789496389857648, -0.0072450132053893945, 1.0822582444561246, -1.5925394155019772, -0.4426706873351689, -0.16959739250543526, 0.2919815813383524, -0.027282386733956887, -1.8758997008207952, 1.8842538611326516, -1.2511773445829362, -0.629675142203125, -1.561278289161041, -1.2263746775603752, -0.8933861177228635, 0.9725518994534865, -1.4546181142758488, -1.1629238249805067, -0.14649268131100968, 1.3035634234493707, 0.1923553100252029, 1.743548570692401, 0.6070479397930733, 1.9585911183006037, 1.1688387229037378, -1.8514215396359095, 1.350895889430837, 1.0088754767003838, -1.2752832690571592, -1.7326967347642004, 1.1488151206912058, 0.8025745975263154, 0.6805884722058115, 1.821605645719245, -0.3298087313855258, 0.11861141439177603, 0.6640335650882401, 0.6679003515544939, 0.18917988212977166, 1.7841094872661518, 0.30375800831927924, 1.8168359374361094, -0.9356159373345867, 0.3531622617510175, -1.4094466763022315, 1.9530571494481466, -1.3593888263925105, 0.2962054773854583, 1.4904251589763833, 1.6278090385151458, 1.9648754099006074, 1.5280825889067589, 1.5490659012022068, -1.0848982886591725, 1.9968548087547138, -0.35722231679263583, 0.08181101574835603, 0.16947417443541601, -1.1879232825278576, -1.066756741651635, -0.5787378683195072, -0.7951148224850613, -0.163297177327955, -0.1454041648173252, 0.12558415249519506, 0.1616707821425547, -1.905213886315396, 0.9335139729097528, 0.4412676860440081, 0.2688944010263792, -1.0454596419362563, 1.3071520163893373, -0.9922681143045677, -1.379111531578412, -1.053843741208056, 1.3510229566423857, -0.8508847988549717, -0.558262681153916, 0.3211978028227467, 0.8716171241936399, -1.1927640270704196, 0.7485677292276285, 0.6083645389300294, -0.598616676852429, -1.6256663839539702, -0.8905315076095799, 0.1623367197923331, 0.807335788584215, -1.811676565838356, 0.08503839706246241, 1.6725461576115839};
const double J[] = {1.2653958648363086, 1.5351634068419004, -0.03505488880059637, -1.9918393406905057, 0.0534715188881818, 0.21347040465873812, -0.9664614653923347, 0.34664456686332823, -0.6810177851356602, -1.9030008511786205, -1.4794260931724872, -1.5441722326101104, 1.1388637618836643, 0.44408554404647305, 1.1868807730760587, -0.1689301602215334, -1.9586383294113001, -1.680457307829919, -1.2213903891626106, -0.49762625907313884, -0.6875187628645678, -1.7571216703445964, 0.12331719712670663, -1.849263984529229, -1.439733998856021, 0.7200882168471083, 1.9538073747289748, -1.282609832349951, -1.953336207975679, 0.698535139014866, 0.5588368401670163, 0.5141378931738063, -0.309544587383225, -0.27321386170553286, 0.028299265129887008, 0.8875344654481907, -0.0581806217555636, -1.6578092975941505, 0.19376670402047003, 1.9958909388215003, 1.2592874999153865, 1.1860227499995388, -1.6945274418984448, -0.20046271149944994, 0.04935421659934747, -0.7969466105587055, -0.07212480341410155, -1.3806724060753686, -1.8187122832414144, -0.3215214842566958, -0.3112069788059748, 0.18790326694224602, -0.7906177418055509, -0.0011174307816168572, 0.2846548419425772, -1.594465031487995, 0.06959306780433483, -0.7727236829150232, 1.8825020294082981, 1.159689290800904, -1.8891903862897594, 0.9201524665718241, 1.4449889607706168, -0.6959389099881239, 0.9605612069857545, 0.9860130126409241, -1.7545736682507203, 0.9966112281258002, -1.443846415069324, 0.9908587240853488, -1.0785750956089588, -0.2911019410551141, -0.5082879453579441, -1.5331914065618015, 1.4776879437676338, -1.6665775793206428, 0.6647683093610257, 1.3678123412682237, 1.859880832742816, -1.1005060533242035, -1.4406950996441314, -0.1728777742206118, -1.453447034981767, 0.025335873057750646, 1.6559527580524795, -1.84569852548166, 1.2991168355026494, -0.6550722418593904, 1.8045920103256359, 0.490437909133703, -1.1384827413990273, -0.6079260137817988, -1.2916663751169697, -1.2182037238239918, -1.8176985856267303, 1.9734778235804864, -1.6827827660628962, 0.08694162961018259, 0.4871478610376849};

void CZ(qbit q1, qbit q2, double phi) {
    // printf("performing Controlled -2phi Z rotation\n");
    Rz(q2, -2.0*phi);
    CNOT(q1, q2);
    Rz(q2, phi);
    CNOT(q1, q2);
}

void ZcrossZ(qbit q1, qbit q2, double phi) {
    // printf("performing sigma_z cross sigma_z Hamiltonian\n");
    Rz(q1, phi);
    Rz(q2, -phi);
    CZ(q1, q2, -2.0*phi);
}


void IsingModel() {
    qbit reg[N];

    // Initialize all qubits to |+> state
    int n;
    for(n=0; n < N; n++) {
        PrepZ(reg[n], 0);
        H(reg[n]);
    }

    double T = 15;  // total duration of adiabatic evolution
    int M = 25;  // number of Trotter steps
    double dt = M / T;  // time per Trotter step

    int m;
    for(m = 1; m <= M; m++) {

        // Z-Z hamiltonian, executed in parallel
        for (n = 0; n < N-1; n += 2) {  // red pairs
            double phi = J[n] * (2.0*m - 1) / M;
            ZcrossZ(reg[n], reg[n + 1], phi);
        }
        for (n = 1; n < N-1; n += 2) {  // black pairs
            double phi = J[n] * (2.0*m - 1) / M;
            ZcrossZ(reg[n], reg[n + 1], phi);
        }

        double theta1 = (1.0 - (2.0*m-1)/M) * -2 * Bx * T / M;
        for (n = 0; n < N; n++) {
            H(reg[n]);
            Rz(reg[n], theta1);
            H(reg[n]);
        }

        // Bz hamiltonian
        for (n = 0; n < N; n++) {
            double theta2 = (1.0 - (2.0*m-1)/M) * -2 * Bz[n] * T / M;
            Rz(reg[n], theta2);
        }
    }


    for (n = 0; n < N; n++) {
        MeasZ(reg[0]);
    }
}


int main() {
    /*
    FILE *fp;
    fp = fopen("input.txt", "r");
    int N = 0;
    double Bx = 0;
    fscanf(fp, "%d", &N);
    fscanf(fp, "%lf", &Bx);
    double Bz[N];
    int i;
    for (i = 0; i < N; i++) {
        fscanf(fp, "%lf", &Bz[i]);
    }
    double J[N-1];
    for (i = 0; i < N-1; i++) {
        fscanf(fp, "%lf", &J[i]);
    }
    */
    
    IsingModel();
    return 0;
}
